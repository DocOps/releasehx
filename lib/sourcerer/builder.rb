# lib/sourcerer/builder.rb
# frozen_string_literal: true

require 'asciidoctor'
require 'fileutils'
require_relative '../sourcerer'

module Sourcerer
  # A build-time code generator that creates assets such as new data, documentation, and even Ruby files from
  # data extracted from AsciiDoc files, such as attributes and tagged regions.
  module Builder
    # Generates a Ruby file at build-time to be used during the build process.
    #
    # @param generated [Hash] A hash with `:path` and `:module` for the generated file.
    # @param attributes [Array<Hash>] A list of attribute sources to build.
    # @param snippets [Array<Hash>] A list of snippets to build.
    # @param regions [Array<Hash>] A list of tagged regions to build.
    # @param templates [Array<Hash>] A list of templates to build (currently unused).
    # @param render [Array<Hash>] A list of render entries (currently unused).
    # rubocop:disable Lint/UnusedMethodArgument
    def self.generate_prebuild generated: {}, attributes: [], snippets: [], regions: [], templates: [], render: []
      # rubocop:enable Lint/UnusedMethodArgument
      # NOTE: templates/render parameters are accepted from config but handled separately by Sourcerer.render_outputs
      attr_result     = build_attributes(attributes)
      snippet_lookup  = build_outputs(snippets, type: :snippet)
      region_lookup   = build_outputs(regions, type: :region)

      File.write(generated[:path].to_s, <<~RUBY)
        # frozen_string_literal: true
        # Auto-generated by Sourcerer::Builder

        module #{generated[:module]}
          ATTRIBUTES = #{attr_result.inspect}

          SNIPPET_LOOKUP = #{snippet_lookup.inspect}

          REGION_LOOKUP = #{region_lookup.inspect}

          def self.read_built_snippet name
            fname = SNIPPET_LOOKUP[name.to_s] || name.to_s
            path = File.expand_path("../../../build/snippets/\#{fname}", __FILE__)
            raise "Snippet not found: \#{name}" unless File.exist?(path)
            File.read(path)
          end
        end
      RUBY
    end

    # @api private
    # Builds a hash of attributes from the given sources.
    # @param attributes [Array<Hash>] The attribute sources.
    # @return [Hash] The built attributes.
    def self.build_attributes attributes
      attributes.each_with_object({}) do |entry, acc|
        source = entry[:source]
        name   = entry[:name] || File.basename(source, '.adoc').to_sym
        acc[name.to_sym] = Sourcerer.load_attributes(source)
      end
    end

    # @api private
    # Builds output files from snippets or regions and returns a lookup hash.
    # @param entries [Array<Hash>] The entries to build.
    # @param type [Symbol] The type of output (`:snippet` or `:region`).
    # @return [Hash] A lookup hash mapping names to output filenames.
    def self.build_outputs entries, type:
      lookup   = {}
      names    = []
      outnames = []

      entries.each do |entry|
        source = entry[:source] or raise ArgumentError, "#{type} entry is missing :source"
        tag    = entry[:tag]
        tags   = entry[:tags]

        raise ArgumentError, 'use only one of :tag or :tags' if tag && tags
        raise ArgumentError, "#{type} must include a :tag or :tags" unless tag || tags

        name    = entry[:name] || tag || File.basename(source, '.adoc')
        outname = entry[:out]  || default_output_name(name, type)

        raise ArgumentError, "name value must be unique; #{name} already used"   if names.include? name
        raise ArgumentError, "out value must be unique; #{outname} already used" if outnames.include? outname

        names    << name
        outnames << outname

        tags = [tag] if tag

        text =
          case type
          when :snippet then Sourcerer.load_include(source, tags: tags)
          when :region  then Sourcerer.extract_tagged_content(source, tags: tags)
          else raise ArgumentError, "Unsupported type: #{type}"
          end

        lookup[name.to_s] = outname

        outpath = File.join("build/#{type}s", outname)
        FileUtils.mkdir_p File.dirname(outpath)
        File.write(outpath, text)
      end

      lookup
    end

    # @api private
    # Determines the default output filename for a given name and type.
    # @param name [String] The name of the output.
    # @param type [Symbol] The type of output.
    # @return [String] The default filename.
    def self.default_output_name name, type
      case type
      when :snippet then "#{name}.txt"
      when :region  then "#{name}.adoc"
      else raise ArgumentError, "Unknown type: #{type}"
      end
    end
  end
end
